void computeGeofacs(const dfloat r, const dfloat s, const dfloat t,
		    const dfloat *VXYZ,
		    dfloat *G00, dfloat *G01, dfloat *G02,
		    dfloat *G11, dfloat *G12, dfloat *G22){
  
  // assume trilinear map
  const dfloat x0 = VXYZ[0],  y0 = VXYZ[1],  z0 = VXYZ[2];
  const dfloat x1 = VXYZ[3],  y1 = VXYZ[4],  z1 = VXYZ[5];
  const dfloat x2 = VXYZ[6],  y2 = VXYZ[7],  z2 = VXYZ[8];
  const dfloat x3 = VXYZ[9],  y3 = VXYZ[10], z3 = VXYZ[11];
  const dfloat x4 = VXYZ[12], y4 = VXYZ[13], z4 = VXYZ[14];
  const dfloat x5 = VXYZ[15], y5 = VXYZ[16], z5 = VXYZ[17];
  const dfloat x6 = VXYZ[18], y6 = VXYZ[19], z6 = VXYZ[20];
  const dfloat x7 = VXYZ[21], y7 = VXYZ[22], z7 = VXYZ[23];

  const dfloat xr =
    (1.f-s)*(1.f-t)*(x1-x0) +
    (1.f+s)*(1.f-t)*(x2-x3) +
    (1.f-s)*(1.f+t)*(x5-x4) +
    (1.f+s)*(1.f+t)*(x6-x7);

  const dfloat xs =
    (1.f-r)*(1.f-t)*(x3-x0) +
    (1.f+r)*(1.f-t)*(x2-x1) +
    (1.f-r)*(1.f+t)*(x7-x4) +
    (1.f+r)*(1.f+t)*(x6-x5);


  const dfloat xt =
    (1.f-r)*(1.f-s)*(x4-x0) +
    (1.f+r)*(1.f-s)*(x5-x1) +
    (1.f-r)*(1.f+s)*(x7-x3) +
    (1.f+r)*(1.f+s)*(x6-x2);

  const dfloat yr =
    (1.f-s)*(1.f-t)*(y1-y0) +
    (1.f+s)*(1.f-t)*(y2-y3) +
    (1.f-s)*(1.f+t)*(y5-y4) +
    (1.f+s)*(1.f+t)*(y6-y7);

  const dfloat ys =
    (1.f-r)*(1.f-t)*(y3-y0) +
    (1.f+r)*(1.f-t)*(y2-y1) +
    (1.f-r)*(1.f+t)*(y7-y4) +
    (1.f+r)*(1.f+t)*(y6-y5);


  const dfloat yt =
    (1.f-r)*(1.f-s)*(y4-y0) +
    (1.f+r)*(1.f-s)*(y5-y1) +
    (1.f-r)*(1.f+s)*(y7-y3) +
    (1.f+r)*(1.f+s)*(y6-y2);


  const dfloat zr =
    (1.f-s)*(1.f-t)*(z1-z0) +
    (1.f+s)*(1.f-t)*(z2-z3) +
    (1.f-s)*(1.f+t)*(z5-z4) +
    (1.f+s)*(1.f+t)*(z6-z7);

  const dfloat zs =
    (1.f-r)*(1.f-t)*(z3-z0) +
    (1.f+r)*(1.f-t)*(z2-z1) +
    (1.f-r)*(1.f+t)*(z7-z4) +
    (1.f+r)*(1.f+t)*(z6-z5);


  const dfloat zt =
    (1.f-r)*(1.f-s)*(z4-z0) +
    (1.f+r)*(1.f-s)*(z5-z1) +
    (1.f-r)*(1.f+s)*(z7-z3) +
    (1.f+r)*(1.f+s)*(z6-z2);

  const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
  const dfloat Jinv = 8.f/J;
  const dfloat rx =  (ys*zt - zs*yt)*Jinv, ry = -(xs*zt - zs*xt)*Jinv, rz =  (xs*yt - ys*xt)*Jinv;
  const dfloat sx = -(yr*zt - zr*yt)*Jinv, sy =  (xr*zt - zr*xt)*Jinv, sz = -(xr*yt - yr*xt)*Jinv;
  const dfloat tx =  (yr*zs - zr*ys)*Jinv, ty = -(xr*zs - zr*xs)*Jinv, tz =  (xr*ys - yr*xs)*Jinv;

  *G00 = rx*rx + ry*ry + rz*rz;
  *G01 = rx*sx + ry*sy + rz*sz;
  *G02 = rx*tx + ry*ty + rz*tz;
  *G11 = sx*sx + sy*sy + sz*sz;
  *G12 = sx*tx + sy*ty + sz*tz;
  *G22 = tx*tx + ty*ty + tz*tz;

}



kernel void ScalarEllipticOperator3D(const int K,
				     const dfloat * restrict D,
				     const dfloat * restrict VXYZ,
				     const dfloat * restrict gz,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict q,
				     const dfloat * restrict fqM,
				     const dfloat * restrict fqP,
				     const dfloat * restrict fdqdnM,
				     const dfloat * restrict fdqdnP,
				     dfloat * restrict Aq){
  
  // only works for Nq>=2
  // uses Nq x Nq x Nq threads until we think of something smarter

  // -----------
  // |    |    |
  // |    |    |
  // -----------
  // |         |
  // |         |
  // |         |
  // |         |
  // -----------

  // (grad v, grad q) + ([v], n.{grad q}) + (n.{grad v}, [q]) + ([v],tau*[q])
  // (grad v, grad q) + (-v, n.{grad q}) + (n.grad v-, (q+ - q-)) + (-v,tau*(q+-q-))
  // (grad v, grad q + delta*n*(q+-q-)) + (-v, n.{grad q} + tau*(q+-q-))
  // (G*grad^ v, G*grad^ q + delta*n*(q+-q-)) + (-v, n.{grad q} + tau*(q+-q-))
  // (grad^ v, G'*G*grad^ q + delta*G'*n*(q+ - q-)) + (-v, n.{grad q} + tau*(q+-q-))

  // independent faces: (0,5), (1,3), (2,4)

  for(int e=0;e<K;++e;outer0){
    
    // 4*p_Nq^3 shared dfloats (1K of shared for Nq=4)
    shared dfloat  s_q[p_Nq][p_Nq][p_Nq];
    shared dfloat s_q0[p_Nq][p_Nq][p_Nq];
    shared dfloat s_q1[p_Nq][p_Nq][p_Nq];
    shared dfloat s_q2[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    shared dfloat s_VXYZ[8*3];
    shared dfloat s_gz[p_Nq];

    exclusive dfloat dq0, dq1, dq2;

    // prefetch to shared memory 
    for(int k=0;k<p_Nq;++k;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  int id = i + j*p_Nq + k*p_Nq2 + e*p_Nq3;
	  s_q[k][j][i] = q[id];
	  if(k==0){
	    s_D[j][i] = D[j*p_Nq + i];
	  }
	  // slows it down ?
	  id = i + j*p_Nq + k*p_Nq*p_Nq;
	  while(id<24){
	    s_VXYZ[id] = VXYZ[e*24+id];
	    id+=p_Nq*p_Nq*p_Nq;
	  }
	  if(j==0 && k==0){
	    s_gz[i] = gz[i];
	  }
	}
      }
    }

    barrier(localMemFence);
    
    // compute first derivatives
    for(int k=0;k<p_Nq;++k;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){

	  dfloat G00, G01, G02, G11 ,G12, G22;
	  // VXYZ + 8*3*e,
	  computeGeofacs(s_gz[i], s_gz[j], s_gz[k], s_VXYZ,
			 &G00, &G01, &G02, &G11, &G12, &G22);
	  
	  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
	  
	  for(int n=0;n<p_Nq;++n){
	    qr += s_D[i][n]*s_q[k][j][n];
	    qs += s_D[j][n]*s_q[k][n][i];
	    qt += s_D[k][n]*s_q[n][j][i];
	  }
	  
	  s_q0[k][j][i] = G00*qr + G01*qs + G02*qt;
	  s_q1[k][j][i] = G01*qr + G11*qs + G12*qt;
	  s_q2[k][j][i] = G02*qr + G12*qs + G22*qt;
	}
      }
    }
    
    barrier(localMemFence);
    
    // faces: (0,5)
    for(int p=0;p<p_Nq;++p;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  if(p<2){ 
	    int f = (p==0) ? 0:5;
	    int k = (p==0) ? 0:p_Nq-1;
	    int idM = e*p_Nq2*p_Nfaces + f*p_Nq2 + j*p_Nq + i; // 3 for 3 components of n
	    int idG = p_Nsgeo*e*p_Nq2*p_Nfaces + f*p_Nq2 + j*p_Nq + i; // 3 for 3 components of n
	    dq0 = fqP[idM]-fqM[idM];
	    
	    // assume sgeo contains G'*n
	    s_q0[k][j][i] += sgeo[idG]*dq0; idG+=p_Nq2;
	    s_q1[k][j][i] += sgeo[idG]*dq0; idG+=p_Nq2;
	    s_q2[k][j][i] += sgeo[idG]*dq0;
	  }
	}
      }
    }
    
    barrier(localMemFence);
    
    // faces: (1,3)
    for(int p=0;p<p_Nq;++p;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  if(p<2){ 
	    int f = (p==0) ? 1:3;
	    int j = (p==0) ? 0:p_Nq-1;
	    int idM = e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + i; // 3 for 3 components of n
	    int idG = p_Nsgeo*e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + i; // 3 for 3 components of n
	    dq1 = fqP[idM]-fqM[idM];
	    
	    // assume sgeo contains G'*n
	    s_q0[k][j][i] += sgeo[idG]*dq1; idG+=p_Nq2;
	    s_q1[k][j][i] += sgeo[idG]*dq1; idG+=p_Nq2;
	    s_q2[k][j][i] += sgeo[idG]*dq1;
	  }
	}
      }
    }
    
    barrier(localMemFence);

    // faces: (2,4)
    for(int p=0;p<p_Nq;++p;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
	for(int j=0;j<p_Nq;++j;inner0){
	  if(p<2){ 
	    int f = (p==0) ? 4:2;
	    int i = (p==0) ? 0:p_Nq-1;
	    int idM = e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + j; // 3 for 3 components of n
	    int idG = p_Nsgeo*e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + j; // 3 for 3 components of n
	    dq2 = fqP[idM]-fqM[idM];
	    
	    // assume sgeo contains G'*n
	    s_q0[k][j][i] += sgeo[idG]*dq2; idG+=p_Nq2;
	    s_q1[k][j][i] += sgeo[idG]*dq2; idG+=p_Nq2;
	    s_q2[k][j][i] += sgeo[idG]*dq2;
	  }    
	}
      }
    }

    barrier(localMemFence);
    
    // compute second (weak) derivatives
    for(int k=0;k<p_Nq;++k;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  
	  dfloat Aq0 = 0.f, Aq1 = 0.f, Aq2 = 0.f;

	  for(int n=0;n<p_Nq;++n){
	    Aq0 += s_D[n][i]*s_q0[k][j][n];
	    Aq1 += s_D[n][j]*s_q1[k][n][i];
	    Aq2 += s_D[n][k]*s_q2[n][j][i];
	  }
	  
	  s_q[k][j][i] = Aq0 + Aq1 + Aq2;
	}
      }
    }

    barrier(localMemFence);

    // add last flux terms

    // faces: (0,5)
    for(int p=0;p<p_Nq;++p;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  if(p<2){ 
	    int f = (p==0) ? 0:5;
	    int k = (p==0) ? 0:p_Nq-1;
	    int idM = e*p_Nq2*p_Nfaces + f*p_Nq2 + j*p_Nq + i; // 3 for 3 components of n
	    int idG = p_Nsgeo*e*p_Nq2*p_Nfaces + f*p_Nq2 + j*p_Nq + i; // 3 for 3 components of n

	    s_q[k][j][i] += -sgeo[idG+ p_idsJ*p_Nq2]*(fdqdnP[idM]+fdqdnM[idM]);
	    s_q[k][j][i] +=  sgeo[idG+p_idtau*p_Nq2]*dq0;
	  }
	}
      }
    }
    
    barrier(localMemFence);
    
    // faces: (1,3)
    for(int p=0;p<p_Nq;++p;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  if(p<2){ 
	    int f = (p==0) ? 1:3;
	    int j = (p==0) ? 0:p_Nq-1;
	    int idM = e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + i; // 3 for 3 components of n
	    int idG = p_Nsgeo*e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + i; // 3 for 3 components of n
	    
	    s_q[k][j][i] += -sgeo[idG+ p_idsJ*p_Nq2]*(fdqdnP[idM]+fdqdnM[idM]);
	    s_q[k][j][i] +=  sgeo[idG+p_idtau*p_Nq2]*dq1;
	  }
	}
      }
    }
    
    barrier(localMemFence);

    // faces: (2,4)
    for(int p=0;p<p_Nq;++p;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
	for(int j=0;j<p_Nq;++j;inner0){
	  if(p<2){ 
	    int f = (p==0) ? 4:2;
	    int i = (p==0) ? 0:p_Nq-1;
	    int idM = e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + j; // 3 for 3 components of n
	    int idG = p_Nsgeo*e*p_Nq2*p_Nfaces + f*p_Nq2 + k*p_Nq + j; // 3 for 3 components of n
	    s_q[k][j][i] += -sgeo[idG+ p_idsJ*p_Nq2]*(fdqdnP[idM]+fdqdnM[idM]);
	    s_q[k][j][i] +=  sgeo[idG+p_idtau*p_Nq2]*dq2;
	  }    
	}
      }
    }

    barrier(localMemFence);

    for(int k=0;k<p_Nq;++k;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  const int id = i + j*p_Nq + k*p_Nq2 + e*p_Nq3;
	  Aq[id] = s_q[k][j][i];
	}
      }
    }

  }
}
